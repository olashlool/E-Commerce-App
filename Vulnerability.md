# E-Commerce-App - Vulnerability Report 

## Vulnerability 1
  - ### Exposure
       Empty String Password makes an account insecure by using an empty string as a password while the users are normally public.

    Empty String Password would have weaken authentication against a brute-force attack on our site and potentially allow access to accounts or some unauthorized parts of the site.

  - ### Repair
    Regisger.cshtml.cs and Login.cshtml.cs contain the vulnerability. We were able to address the vunerability by using ASP.NET Core Identity as it provides the following safeguard:

    By default, Identity requires that passwords contain an uppercase character, lowercase character, a digit, and a non-alphanumeric character. Passwords must be at least six characters long.
    Identity was enabled by calling UseAuthentication from Startup.cs.

## Vulnerability 2

  - ### Exposure
    Password plaintext storage means storing passwords in a database in the origin state without hashing them.

    Storing a password in plaintext may result in a system compromise. Anyone who can access the database can access the password-protected resource. A good password management should never store a password in plaintext.

  - ### Repair
    By default, ASP.NET Identity Framework implements password hasher that adds random salt to the passwords. If without this function, Regisger.cshtml.cs would have contained the vulnerability.

    In Microsoft.AspNetCore.Identity, class UserManager< TUser> implements IPasswordHasher< TUser> interface that contains a function HashPassword to hash the password.
    IPasswordHasher was enabled by using Identity's class UserManager in Regisger.cshtml.cs.

## Vulnerability 3 
  - ### Exposure
    Creating and using insecure temporary files can leave application and system data vulnerable to attacks.

    If the attacker knows where the application creates its temporary files and can guess the name of the next temporary file, security problems may occur.

  - ### Repair
    ProductController.cs contains the vulnerability. We were able to address the vulnerability by using ValidateAntiForgeryToken attribute in ASP.NET Core.

    ValidateAntiForgeryToken attribute specifies that the class or method that this attribute is applied validates 
    the anti-forgery token. If the anti-forgery token is not available, or if the token is invalid, the validation will 
    fail and the action method will not execute. This attribute helps defend against cross-site request forgery.
